# Taleus Tally Structure and Operations

This document describes the structure of tallies in Taleus and the operations that can be performed on them.

## Tally Overview

A tally is a digital contract between two parties that:
- Formalizes a trusted trading relationship
- Establishes credit terms
- Records transactions (chits) between the parties
- Enables credit-based exchanges of value

## Evolution from MyCHIPs Implementation

Taleus builds upon the [MyCHIPs](https://github.com/gotchoices/MyCHIPs) tally concept but adapts it for a shared database model. The original MyCHIPs implementation stored tallies as:

1. **Tally header** - contained party identification, contract, initial terms
2. **Chits** - originally for payments only, but settings and trading variables were later "wedged into" the same table
3. **Hash-chain structure** - for consensus verification between separate party databases

Taleus improves upon this by:
- Using a shared database with 50/50 consensus voting
- Breaking tally data into discrete, negotiable chunks
- Supporting progressive disclosure and revision-based negotiation
- Maintaining cryptographic signatures for legal dispute resolution

## Tally Bootstrap Process

Bootstrap details are maintained separately. See `doc/design/bootstrap.md`.

### Multi-Use Token Implications

- Each successful respondent gets their own isolated database instance and unique tally
- Initiator can reject respondents during validation phase without resource commitment
- Multiple simultaneous negotiations are managed through separate database instances
- Token expiration prevents new initiations but doesn't affect active negotiations or tallies
- Failed validations don't consume multi-use token (remains available for other respondents)

## Tally Data Chunks

In Taleus, tally data is organized into discrete chunks that can be negotiated independently during tally establishment. Each chunk type serves a specific purpose and follows its own revision and signature patterns.

### 1. Tally Identity Chunk

**Purpose**: Establishes basic tally identity that all other chunks reference

**Content**:
- **Protocol Version**: Taleus protocol version information
- **Creation Timestamp**: When the tally was initially established
- **Stock Holder ID**: The initiating party's libp2p peer ID (hash of their master key)
- **Foil Holder ID**: The responding party's libp2p peer ID (hash of their master key)
- **Stock Master Key**: Stock holder's master public key (for validating derived keys)
- **Foil Master Key**: Foil holder's master public key (for validating derived keys)
- **Tally UUID**: Generated as a hash of all the above fields (provides unique tally identifier)

**Issuing Party**: Stock holder (initiator)
**Signature Requirement**: Unilateral (issuer signs), operability via Configuration Signature Block
**Negotiation Pattern**: 
- Generated by the initiator during database instantiation (after receiving respondent's Party ID)
- Included in the database when access is granted to the respondent
- Signed by the stock holder (immutable once signed)
- Becomes operative when referenced in an active Tally Configuration

### 2. Party Certificate Chunk (per party, revisioned)

**Purpose**: Identity disclosure and verification data that parties share with each other

**Content**:
- **Names**: All names the party has been known by
- **Communication Points**: Phone, email, web addresses
- **Physical Addresses**: Home, mailing, shipping addresses
- **Documents/Files**: Images, scans, documents (may use content addresses like IPFS)
- **Current Public Key**: Active derived public key for current operations

**Issuing Party**: Self (each party creates their own)
**Signature Requirement**: Unilateral (only the issuing party signs)
**Negotiation Pattern**:
- Each party can disclose progressively more information through revisions
- Append-only with increasing revision numbers (older revisions remain accessible)
- Self-certification: only the disclosing party signs their own certificate

**Example Negotiation Flow**:
1. Stock party creates basic certificate (revision 1) with minimal information
2. Foil party objects to insufficient identifying data
3. Stock party creates enhanced certificate (revision 2) with more complete information
4. Foil party accepts the enhanced certificate
5. Negotiation proceeds to other tally aspects

### 3. Key Issuance Chunk (per party, per key change)

**Purpose**: Records issuance of new derived keys while maintaining master key continuity

**Content**:
- **Issuing Party**: Which party (stock or foil) is issuing the new key
- **New Public Key**: The new derived public key for operations
- **Key Derivation Proof**: Cryptographic proof that new key derives from master key
- **Effective Timestamp**: When the new key becomes active
- **Previous Key Reference**: Reference to the previously active key (if any)

**Issuing Party**: Self (each party manages their own keys)
**Signature Requirement**: Unilateral (issuer signs), operability via Configuration Signature Block
**Negotiation Pattern**:
- Either party can issue new derived keys as needed
- Must provide cryptographic proof of derivation from master key (in Tally Identity Chunk)
- Becomes operative when referenced in an active Tally Configuration
- Enables key rotation without closing the tally

### 4. Credit Terms Chunk (per party extending credit, revisioned)

**Purpose**: Defines credit limits and terms one party extends to another

**Content**:
- **Credit Limit**: Maximum credit amount extended
- **Call Term**: Number of days notice required to reduce the limit
- **Additional Terms**: Other credit parameters and conditions

**Issuing Party**: Self (each party sets credit they're willing to extend)
**Signature Requirement**: Unilateral (only the grantor of credit signs)
**Negotiation Pattern**:
- Each party can independently offer credit terms to the other
- New revision created for each change
- Restrictive changes only take effect after the call term expires
- Only the party extending the credit needs to sign

### 5. Contract Reference Chunk (revisioned)

**Purpose**: References the governing contract document that defines the legal agreement

**Content**:
- **Contract ID**: Content-addressable reference (e.g., IPFS hash)
- **Contract Format**: Document structure specification (PDF, structured YAML, etc.)
- **Document Type**: Identifier for contract template or type

**Issuing Party**: Either (whoever proposes the contract)
**Signature Requirement**: Unilateral (proposer signs), operability via Configuration Signature Block
**Negotiation Pattern**:
- Either party can propose a new contract reference
- New revision for each contract proposal
- Becomes operative when referenced in an active Tally Configuration
- Nodes hosting the tally are expected to cache referenced contracts

### 6. Trading Variables Chunk (per party, revisioned)

**Purpose**: Automated trading parameters that control credit lifts from each party's perspective

**Content** (based on [mychips/schema/tallies.wmt](https://github.com/gotchoices/MyCHIPs/blob/master/schema/tallies.wmt)):
- **Bound**: Upper limit of credit that may be produced by any lift
- **Target**: Ideal balance to be reached by lifting
- **Margin**: Amount to charge for lifts exceeding target
- **Clutch**: Amount to charge for reverse lifts (drops)

**Issuing Party**: Self (each party sets their own variables)
**Signature Requirement**: Unilateral (only the setting party signs)
**Negotiation Pattern**:
- Each party sets their own variables independently
- Only affects that party's perspective of the tally
- Can be updated independently by each party
- Only the party setting the variables needs to sign

### 7. Operational Chit Chunks (individual records)

**Purpose**: Transaction records and operational changes during active tally operation

#### Chit Digest Format

Each chit follows a standardized digest format for cryptographic signing:
- **Tally ID**: ID of the tally the chit belongs to
- **Party Indicator**: Which party is issuing the pledge (stock 's' or foil 'f')
- **Date**: Date of the pledge (format: YYYY-MM-DDTHH:mm:ss.SSSZ in UTC)
- **Memo**: Human readable comment
- **Reference**: Machine readable JSON data
- **Units**: Integer number of milliCHIPs as a positive number

#### Chit Types

**Pledge Chits**: Recording actual value transfers between parties
- Represents a promise of value from one party to another
- Affects the tally balance (net sum of all valid chits)
- Creates either assets (positive) or liabilities (negative) for each party

**Chit Requests**: Requesting payment from the other party
- Signed by the party requesting payment
- Other party processes the request and creates a corresponding pledge chit
- Enables formal payment request workflows

**Setting Chits**: Changes to operational parameters
- Modifications to trading variables or other tally settings
- Signed by the party making the change
- May require consensus validation depending on the type of change

**Issuing Party**: Either (whoever creates the chit)
**Signature Requirement**: Consensus (database validation + creating party signature)
**Negotiation Pattern**:
- Created by one party during active tally operation
- Validated through the shared database consensus mechanism
- Signed by the creating party using their cryptographic key
- Parties maintain local copies of chits that protect their position

### 8. Tally Configuration Signature Block (revisioned)

**Purpose**: Establishes which combination of chunk revisions constitutes the operative tally

**Content**:
- **Configuration Revision**: Incrementing number for this signature block
- **Required Chunks**: Array of (chunk_type, chunk_revision) pairs referencing all required chunks
- **Stock Signature**: Stock holder's acceptance of this exact configuration  
- **Foil Signature**: Foil holder's acceptance of this exact configuration
- **Supersedes Configuration**: Reference to previous configuration revision (if any)
- **Configuration Timestamp**: When this configuration was proposed

**Issuing Party**: Either (whoever proposes the configuration)
**Signature Requirement**: Bilateral (both parties must sign identical configuration)
**Negotiation Pattern**:
- Either party can propose a new tally configuration by referencing specific chunk revisions
- Configuration becomes operative only when both parties sign the same configuration revision
- Supersedes any previous active configuration when both signatures are present
- Individual chunks remain "draft" until referenced by an active configuration
- Enables clean amendment process: propose new configuration → both parties sign → new terms take effect

**Example Configuration Flow**:
1. Stock party proposes Configuration Rev 1 referencing: Identity(1), Certificate-Stock(2), Certificate-Foil(1), Contract(1), etc.
2. Foil party signs the same Configuration Rev 1
3. Tally becomes operative under those exact chunk revisions
4. Later, either party proposes Configuration Rev 2 with updated chunk references
5. Both parties sign Configuration Rev 2 → amendment takes effect

### 9. Close Request Chunk (if applicable)

**Purpose**: Formal request to close the tally when conditions are met

**Content**:
- **Close Request Flag**: Indicates intent to close
- **Requesting Party**: Identifier of party requesting closure
- **Request Timestamp**: When the request was made

**Issuing Party**: Either (whoever requests closure)
**Signature Requirement**: Must be referenced in a Tally Configuration Signature Block for effect
**Negotiation Pattern**:
- Either party can create a close request chunk
- Close request only takes effect when referenced in an active tally configuration
- The tally remains open until its balance reaches zero
- Zero balance can be achieved through lifts or manual chits
- A closing tally should only accept chits that move it closer to zero

## Minimum Required Chunks for Valid Tally

For a tally to be considered valid and operational, the following chunks must be present and referenced in an active Tally Configuration Signature Block:

### **Essential Chunks** (required):
1. **Tally Identity Chunk** (revision 1) - Establishes basic tally identity and party roles
2. **Party Certificate Chunk** (at least 1 revision per party) - Basic identity disclosure from each party
3. **Contract Reference Chunk** (at least 1 revision) - Legal framework governing the relationship
4. **Credit Terms Chunk** (at least 1 revision per party) - Credit limits each party extends to the other

### **Optional Chunks** (may be required by specific contracts):
5. **Key Issuance Chunk** - Only required if derived keys differ from master keys
6. **Trading Variables Chunk** - Required if tally participates in automated credit lifts
7. **Close Request Chunk** - Only present when tally closure is being negotiated

### **Validation Rules**:
- All essential chunks must be present and referenced in the active configuration
- Each party must have provided at least basic certificate information
- Contract reference must point to a valid, accessible contract document
- Credit terms may be zero (no credit extended) but chunks must still exist
- Configuration must be signed by both parties to be considered valid

### **Important Distinction: Zero Credit vs. Close Request**

**Zero Credit Terms**:
- Means "I'm not willing to extend any new credit to you"
- Tally remains **open** and fully operational
- Parties can still receive payments, make payments from positive balances, and participate in credit lifts
- Credit limits can be increased again in the future through new Credit Terms revisions
- Common scenarios: temporary credit suspension, maxed out credit limits, risk management

**Close Request**:
- Means "I want to terminate this entire tally relationship"
- Tally moves to **closing** state with goal of permanent settlement
- Focus shifts to achieving zero balance and then closing the tally permanently
- Typically used when business relationship is ending (contract expiration, relocation, disputes)
- More final in nature - represents intent to end the relationship entirely

These are fundamentally different operational states that serve different purposes in tally lifecycle management.

## Tally States

A tally progresses through several states during its lifecycle:

1. **Draft**: Initial creation by initiating party, chunk negotiation in progress
2. **Offered**: Core chunks agreed upon, awaiting final acceptance  
3. **Open**: All essential chunks present in active configuration, ready for transactions
4. **Closing**: Close request registered, working toward zero balance
5. **Closed**: Balance is zero, no more transactions allowed
6. **Void**: Rejected or abandoned during negotiation

## Negotiation Protocol

### Chunk-Based Negotiation Flow

1. **Initialization**: Stock holder creates Tally Identity chunk
2. **Chunk Development**: Both parties create and revise individual chunks:
   - Party Certificate chunks (progressive disclosure)
   - Credit Terms chunks (independent proposals)
   - Contract Reference chunks (negotiated proposals)
   - Trading Variables chunks (independent settings)
3. **Configuration Proposal**: Either party proposes a Tally Configuration referencing specific chunk revisions
4. **Configuration Review**: Other party reviews the complete configuration and may:
   - Sign the configuration (accepting the tally terms)
   - Propose alternative chunk revisions and create competing configuration
   - Request changes to individual chunks before signing
5. **Activation**: Tally becomes "Open" when both parties sign the same configuration revision
6. **Amendment Process**: Future changes require new configuration proposals referencing updated chunks

### Revision Management

- Each chunk type maintains its own revision sequence
- Revisions are append-only and cryptographically signed
- Chunks exist in "draft" state until referenced by an active Tally Configuration
- Multiple revisions of the same chunk can coexist - operability is determined by configuration reference
- All revisions are preserved for audit and dispute resolution
- Tally Configuration Signature Blocks determine which combination of chunk revisions is operative

### Database Schema Implications

Each chunk type will have its own table in the normalized SQL schema:

**Common Fields** (all chunk tables):
- `tally_id` (UUID, foreign key reference)
- `chunk_type` (enumerated type)
- `revision` (integer, incrementing)
- `issuing_party` (stock 's' or foil 'f' - who created/disclosed this chunk)
- `issuing_party_signature` (signature from the party who created this chunk)
- `timestamp` (creation time)
- `status` (draft, referenced_in_config, superseded)

**Tally Configuration Table** (separate table):
- `tally_id` (UUID, foreign key reference)
- `config_revision` (integer, incrementing)
- `chunk_references` (JSON array of {chunk_type, chunk_revision} objects)
- `stock_signature` (stock holder's signature accepting this configuration)
- `foil_signature` (foil holder's signature accepting this configuration)
- `timestamp` (when configuration was proposed)
- `effective_timestamp` (when both signatures present - configuration becomes active)
- `supersedes_config` (reference to previous active configuration)

**Type-Specific Fields**:
- Varied based on chunk type requirements
- JSON fields used where flexibility is needed (certificates, contract references)
- Normalized fields for structured data (credit limits, trading variables)

## Security Considerations

The chunk-based approach incorporates several security features:

1. **Cryptographic Signatures**: All chunks are signed by the creating/agreeing parties
2. **Immutable Records**: Signed chunks cannot be altered, only superseded
3. **Progressive Disclosure**: Parties can reveal information incrementally as trust builds
4. **Dispute Resolution**: Complete audit trail of all chunk revisions and signatures
5. **Local Backup**: Parties maintain copies of chunks that protect their interests

## Consensus and Integrity

- **Shared Database Consensus**: 50/50 voting power split between party-nominated nodes
- **Chunk Validation**: Database constraints ensure valid chunk sequences and signatures
- **Hash Chain Integration**: May be added for additional integrity verification beyond database consensus
- **Byzantine Resilience**: Consensus mechanism prevents unilateral tally modifications

## Implementation Benefits

This chunk-based approach provides:

- **Granular Negotiation**: Each aspect can be negotiated independently
- **Progressive Trust Building**: Information disclosure can match trust development
- **Clear Revision Tracking**: Every change is versioned and cryptographically verified
- **Flexible Schema**: JSON fields accommodate varying certificate and contract formats
- **Legal Compliance**: Complete signature chain for dispute resolution and legal proceedings

---

*Note: This document reflects the current design decisions for Taleus. The chunk structure may be refined during implementation based on technical requirements and user feedback.*